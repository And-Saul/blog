{
  "hash": "2a3c1c45c42da26c8b29b7c764f024e1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: \"2025-02-17\"\ncategories: [R Tutorial] \nimage: \"image.png\" \nlightbox: true \nformat:    \n  html:     \n    fig-numbering: true     \n    tbl-cap-location: top \n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n\n# Functions in the tidyverse\n\n**Functions were created in the epoch before tidyverse**. Hacks are required to successfully use tibbles and dataframes within functions. Problems occur because functions assume all data is contained within vectors.\n\n**Examples using tibbles within functions**\n\nCreate tibble containing one independent variable (ColA), and several dependent variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntib <- tibble(\n                ColA = 1:10,\n                ColB = ColA + rnorm(10),              # 1:1 relationship\n                ColC = ColA + 15 + rnorm(10),          # add 15 \n                ColD = ColA^2 + rnorm(10),            # Square Col A   \n                ColE = 2^ColA + rnorm(10, 0, 30)      # 2^ColA\n                )\n\ntitlenames <- c(\"Title B\", \"Title C\", \"Title D\", \"Title E\")\n```\n:::\n\n\n\nThe plot of ColA vs ColB\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntib %>% \n  ggplot(aes(x=ColA, y=ColB))+\n  geom_point()+\n  ggtitle(titlenames[1])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nCopy and paste the above code multiple times, changing the appropriate variables (eg. y, ggtitle).\n\nCopy and pasting becomes messy and prone to errors (may forget to change a variable!)\n\nBetter solution is to create a user-defined function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# won't work!\ncreate_plot_bug <- function(df = tib,\n                            xvar = ColA,\n                            yvar = ColB, \n                            titlename = titlenames[1]) {\n  df %>% \n  ggplot(aes(x=xvar, y=yvar))+\n  geom_point()+\n  ggtitle(titlename)\n}\n\ntry(create_plot_bug(df=tib, yvar= ColB, titlename = \"Title B\"))\n```\n:::\n\n\n\nError! ColA and ColB are objects not found in the Global Environment (environment where function was called)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_plot <- function(df = tib,\n                        xvar = ColA,\n                        yvar = ColB, \n                        titlename = titlenames[1]) {\n  df %>% \n  ggplot(aes(x={{xvar}}, y={{yvar}}))+\n  geom_point()+\n  ggtitle(titlename)\n}\n\np1 <- create_plot(df=tib, yvar= ColB, titlename = titlenames[1])\np2 <- create_plot(df=tib, yvar = ColC, titlename = titlenames[2])\np3 <- create_plot(df=tib, yvar = ColD, titlename = titlenames[3])\np4 <- create_plot(df=tib, yvar = ColE, titlename = titlenames[4])\n\nlist(p1,p2,p3,p4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[2]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[3]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[4]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-4.png){width=672}\n:::\n:::\n\n\n\nThe above solution works, but again is cumbersome and human error may result.\n\nUse map function to automatically generate and store above plots\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create vector with tibble columns\nyvars <- try(c(ColB, ColC, ColD, ColE)) # !!! Does not work\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in eval(expr, envir) : object 'ColB' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nyvars <- c(\"ColB\", \"ColC\", \"ColD\", \"ColE\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# try with quoted column names\n#tib_single_col <- tib[\"ColB\"]\n\nvector_colB <- tib[[\"ColB\"]]\n```\n:::\n\n\n\nThe Holy Grail !!!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Does the function work using one set of values?\ncreate_plot_quotes1 <- function(df = tib,\n                               xvar = \"ColA\",\n                               yvar = \"ColB\",\n                               titlename = titlenames[1]) {\n  \n  df %>%\n    ggplot(aes(x=.data[[xvar]], y=.data[[yvar]]))+\n    geom_point()+\n    ggtitle(titlename)\n}\n\ncreate_plot_quotes1()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# .data is pronoun specific to dplyr (tidy evaluation) & rlang.\n# It represents the most updated version of the tibble\n#eg. mtcars %>%\n        # mutate(\n        # cyl2 = cyl + 1,\n        # am3 = .data[[\"cyl2\"]] + 10\n        # ) \n# works!\n\n# -----------  OR ----------------------------------------------\ncreate_plot_quotes2 <- function(df = tib,\n                               xvar = ColA,\n                               yvar = \"ColB\",\n                               titlename = titlenames[1]) {\n  plot_obj <- \n    df %>%\n    ggplot(aes(x={{xvar}}, y=.data[[yvar]]))+\n    geom_point()+\n    ggtitle(titlename)\n  \n  assign(paste0(\"plot_\", yvar), plot_obj, envir = .GlobalEnv)\n}\n\ncreate_plot_quotes2()\n```\n:::\n\n\n\nUse map function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconstant_title_list <-\n  map(yvars, \\(x) create_plot_quotes2(df=tib,\n                                   xvar = ColA,\n                                   yvar = x,\n                                   titlename = \"The title of the plot is constant\"))\n\ntry(constant_title_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[2]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[3]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[4]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-4.png){width=672}\n:::\n:::\n\n\n\nUse map2 function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitle_change_list <- map2(yvars, titlenames,\n                      \\(x,y) create_plot_quotes2(df=tib,\n                                                 xvar = ColA,\n                                                 yvar = x,\n                                                 titlename = y))\n\ntry(title_change_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[2]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[3]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[4]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-4.png){width=672}\n:::\n:::\n\n\n\n# Injecting indefinite multiple values into user functions\n\n(useful with group_by)\n\n## Two methods\n\n### First method (...)\n\nThe dot.dot.dot (...) pattern must be placed at the end of the parameter list in the formals section of the user-defined function. All parameters must be declared when calling the function, irrespective if a parameter has a default value. The (...) can be used directory in a tidyverse function eg. group_by, or can first be saved to a list object, preferably using the rlang::list2 function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntib_small <-\n  tibble(colA = rnorm(50),\n         colB = rep(letters[1:5], times = 10),\n         colC = rep(LETTERS[1:5], each = 10))\n\nfunc_dots <- function(df, field1, ...){\n  df %>%\n    group_by(...) %>%\n    summarise(mean = mean({{field1}}, na.rm = T))\n}\n\nfunc_dots(df = tib_small, colA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n     mean\n    <dbl>\n1 -0.0774\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_dots(df = tib_small, colB, colA) #Error : colB is in field 1 place. Can't sum a character vector\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 50 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `mean = mean(colB, na.rm = T)`.\nℹ In group 1: `colA = -2.685066`.\nCaused by warning in `mean.default()`:\n! argument is not numeric or logical: returning NA\nℹ Run `dplyr::last_dplyr_warnings()` to see the 49 remaining warnings.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50 × 2\n     colA  mean\n    <dbl> <dbl>\n 1 -2.69     NA\n 2 -2.14     NA\n 3 -1.84     NA\n 4 -1.39     NA\n 5 -1.38     NA\n 6 -1.08     NA\n 7 -1.01     NA\n 8 -0.938    NA\n 9 -0.911    NA\n10 -0.814    NA\n# ℹ 40 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_dots(df = tib_small, colA, colB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  colB     mean\n  <chr>   <dbl>\n1 a     -0.0311\n2 b     -0.406 \n3 c      0.433 \n4 d     -0.142 \n5 e     -0.242 \n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_dots(df = tib_small, colA, colB, colC)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'colB'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n# Groups:   colB [5]\n   colB  colC      mean\n   <chr> <chr>    <dbl>\n 1 a     A      0.129  \n 2 a     B     -0.357  \n 3 a     C     -0.501  \n 4 a     D      0.0427 \n 5 a     E      0.532  \n 6 b     A      0.281  \n 7 b     B      0.0848 \n 8 b     C     -1.29   \n 9 b     D     -1.10   \n10 b     E     -0.00374\n# ℹ 15 more rows\n```\n\n\n:::\n:::\n\n\n\n### Second method\n\nUse a vector in place of dot.dot.dot. Order of arguments in formal section of user-function not critical. In order to convert the character strings of vector_args into selecting the columns in the dataframe, the function combination \"across(all_of(vector_args))\" must be used in a tidy function such as group_by, select etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_vector_parameter <- function(df, field1, vector_args, quote = NULL){\n  obj <-\n    df %>%\n    group_by(across(all_of(vector_args))) %>%\n    summarise(mean = mean({{field1}}, na.rm = T))\n\n  if(!is.null(quote)){\n    message(\"My quote is \", quote)\n    return(obj)\n  }\n\n  return(obj)\n\n}\n\n# Example where order of parameters matters.\nfunc_vector_parameter(df = tib_small, field1 = colA, vector_args = c(\"colB\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  colB     mean\n  <chr>   <dbl>\n1 a     -0.0311\n2 b     -0.406 \n3 c      0.433 \n4 d     -0.142 \n5 e     -0.242 \n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_vector_parameter(df = tib_small, field1 = colA, vector_args = c(\"colB\"), quote = \"Hello\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMy quote is Hello\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  colB     mean\n  <chr>   <dbl>\n1 a     -0.0311\n2 b     -0.406 \n3 c      0.433 \n4 d     -0.142 \n5 e     -0.242 \n```\n\n\n:::\n\n```{.r .cell-code}\n# default NULL field must be specified after multiple argument field\n\nfunc_vector_parameter(df = tib_small, field1 = colA, vector_args = c(\"colB\", \"colC\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'colB'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n# Groups:   colB [5]\n   colB  colC      mean\n   <chr> <chr>    <dbl>\n 1 a     A      0.129  \n 2 a     B     -0.357  \n 3 a     C     -0.501  \n 4 a     D      0.0427 \n 5 a     E      0.532  \n 6 b     A      0.281  \n 7 b     B      0.0848 \n 8 b     C     -1.29   \n 9 b     D     -1.10   \n10 b     E     -0.00374\n# ℹ 15 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_vector_parameter(tib_small, colA, c(\"colB\", \"colC\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'colB'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n# Groups:   colB [5]\n   colB  colC      mean\n   <chr> <chr>    <dbl>\n 1 a     A      0.129  \n 2 a     B     -0.357  \n 3 a     C     -0.501  \n 4 a     D      0.0427 \n 5 a     E      0.532  \n 6 b     A      0.281  \n 7 b     B      0.0848 \n 8 b     C     -1.29   \n 9 b     D     -1.10   \n10 b     E     -0.00374\n# ℹ 15 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc_vector_parameter(df = tib_small, vector_args = c(\"colB\", \"colC\"), field1 = colA)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'colB'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n# Groups:   colB [5]\n   colB  colC      mean\n   <chr> <chr>    <dbl>\n 1 a     A      0.129  \n 2 a     B     -0.357  \n 3 a     C     -0.501  \n 4 a     D      0.0427 \n 5 a     E      0.532  \n 6 b     A      0.281  \n 7 b     B      0.0848 \n 8 b     C     -1.29   \n 9 b     D     -1.10   \n10 b     E     -0.00374\n# ℹ 15 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# Can insert a vector as argument of parameter\nv_args <- c(\"colB\", \"colC\")\nfunc_vector_parameter(df = tib_small, field1 = colA, vector_args = v_args)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'colB'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n# Groups:   colB [5]\n   colB  colC      mean\n   <chr> <chr>    <dbl>\n 1 a     A      0.129  \n 2 a     B     -0.357  \n 3 a     C     -0.501  \n 4 a     D      0.0427 \n 5 a     E      0.532  \n 6 b     A      0.281  \n 7 b     B      0.0848 \n 8 b     C     -1.29   \n 9 b     D     -1.10   \n10 b     E     -0.00374\n# ℹ 15 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}